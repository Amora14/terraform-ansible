name: Deploy VM with Terraform and Ansible

# Gatilhos para a pipeline
on:
  push:
    branches:
      - main # A pipeline roda automaticamente em pushes para a branch 'main'
  workflow_dispatch: # Permite acionar a pipeline manualmente na interface do GitHub Actions

# Variáveis de ambiente que serão usadas por toda a pipeline
env:
  TF_WORKING_DIR: ./terraform # Caminho para os arquivos Terraform
  ANSIBLE_WORKING_DIR: ./ansible # Caminho para os arquivos Ansible
  
  # Variáveis do GCP e SSH, obtidas dos secrets
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SSH_USER: ${{ secrets.SSH_USER }}
  
  # Variáveis do repositório da aplicação, obtidas dos secrets
  APP_REPO_URL: ${{ secrets.APP_REPO_URL }}
  APP_REPO_BRANCH: ${{ secrets.APP_REPO_BRANCH }}
  
  # Variáveis de ambiente para as credenciais do banco de dados, obtidas dos secrets
  # Estas serão passadas para o Ansible, que as usará para criar o arquivo .env na VM
  MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
  MYSQL_DATABASE_NAME: ${{ secrets.MYSQL_DATABASE_NAME }}
  MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
  MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}

jobs:
  deploy-vm:
    runs-on: ubuntu-latest # O tipo de runner (máquina virtual) onde a pipeline será executada

    steps:
      - name: Checkout Repository # Clona seu repositório de IaC (terraform/ansible) para o runner
        uses: actions/checkout@v4

      # --- Configuração e Execução do Terraform ---
      - name: Setup Terraform # Instala a CLI do Terraform no runner
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.x.x # Defina a versão do Terraform que você está usando (ex: 1.6.x, 1.7.x)

      - name: Authenticate to GCP # Autentica o runner no Google Cloud usando a chave da conta de serviço
        id: "auth"
        uses: "google-github-actions/auth@v2"
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud CLI # Configura o projeto padrão para a CLI do gcloud
        run: gcloud config set project ${{ env.GCP_PROJECT_ID }}

      - name: Terraform Init # Inicializa o Terraform (baixa provedores, configura backend, etc.)
        run: terraform init
        working-directory: ${{ env.TF_WORKING_DIR }} # Executa o comando no diretório 'terraform/'

      - name: Terraform Apply # Executa o Terraform para provisionar a VM e as regras de firewall
        id: tf_apply # Dá um ID para este passo para poder capturar suas saídas
        run: terraform apply -auto-approve \
             -var="gcp_project_id=${{ env.GCP_PROJECT_ID }}" \
             -var="ssh_user=${{ env.SSH_USER }}" \
             -var="ssh_public_key_path=/home/runner/.ssh/id_rsa.pub" # Usa a chave pública padrão do runner
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Get Terraform Outputs # Captura o IP da VM e o usuário SSH das saídas do Terraform
        id: tf_outputs
        run: |
          sudo apt-get update && sudo apt-get install -y jq # Garante que 'jq' esteja instalado para processar JSON
          terraform output -json > terraform_outputs.json # Exporta as saídas do Terraform como JSON
          echo "INSTANCE_IP=$(cat terraform_outputs.json | jq -r '.instance_ip.value')" >> $GITHUB_ENV # Extrai o IP e o define como var de ambiente
          echo "SSH_USER_OUTPUT=$(cat terraform_outputs.json | jq -r '.ssh_user.value')" >> $GITHUB_ENV # Extrai o usuário SSH e define como var de ambiente
        working-directory: ${{ env.TF_WORKING_DIR }}

      # --- Configuração e Execução do Ansible ---
      - name: Setup Python and Install Ansible # Instala Python e o Ansible no runner
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      - run: pip install ansible community.docker # Instala Ansible e o módulo Docker necessário

      - name: Configure SSH Private Key for Ansible # Configura a chave privada SSH do runner para o Ansible
        run: |
          mkdir -p ~/.ssh # Garante que o diretório .ssh existe
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa # Salva a chave privada do secret
          chmod 600 ~/.ssh/id_rsa # Define permissões seguras para a chave privada
          # Adiciona o host (VM) ao known_hosts para evitar o prompt de confirmação SSH na primeira conexão
          # O '|| true' no final permite que o comando continue mesmo se houver um erro (ex: host ainda não disponível)
          ssh-keyscan -H ${{ env.INSTANCE_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Create Ansible Inventory # Cria o arquivo de inventário dinâmico para o Ansible
        run: |
          sed -e "s|{{ instance_ip }}|${{ env.INSTANCE_IP }}|g" \
              -e "s|{{ ssh_user }}|${{ env.SSH_USER_OUTPUT }}|g" \
              ${{ env.ANSIBLE_WORKING_DIR }}/inventory.ini.template > ${{ env.ANSIBLE_WORKING_DIR }}/inventory.ini
        working-directory: ${{ env.ANSIBLE_WORKING_DIR }} # Executa o comando no diretório 'ansible/'

      - name: Run Ansible Playbook # Executa o playbook Ansible
        run: ansible-playbook -i inventory.ini playbook.yaml
        working-directory: ${{ env.ANSIBLE_WORKING_DIR }}
        env: # Passa as variáveis de ambiente para o Ansible (especialmente para o template .env do MySQL)
          MYSQL_ROOT_PASSWORD: ${{ env.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE_NAME: ${{ env.MYSQL_DATABASE_NAME }}
          MYSQL_USERNAME: ${{ env.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ env.MYSQL_PASSWORD }}
          ANSIBLE_HOST_KEY_CHECKING: "False" # Desativa a verificação de hostkey para VMs efêmeras (CUIDADO em produção, mas comum em testes de CI/CD)

      # --- Destruir a VM (Opcional: para testes e evitar custos) ---
      # Descomente este bloco se você quiser que a VM seja automaticamente destruída
      # após cada execução BEM-SUCEDIDA da pipeline. Muito útil para aprender e evitar custos.
      # - name: Terraform Destroy (Optional - for ephemeral environments)
      #   if: always() # Garante que este passo sempre rodará, mesmo se os anteriores falharem
      #   run: terraform destroy -auto-approve \
      #        -var="gcp_project_id=${{ env.GCP_PROJECT_ID }}" \
      #        -var="ssh_user=${{ env.SSH_USER }}" \
      #        -var="ssh_public_key_path=/home/runner/.ssh/id_rsa.pub"
      #   working-directory: ${{ env.TF_WORKING_DIR }}
